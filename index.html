<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">

<section>Why?</section>
<section>Why do we want to run stuff on JS?</section>
<section>
JS is in the browser
</section>
<section>
JS is getting everywhere else
</section>
<section>
React.native
</section>
<section>
node.js
</section>

<section>
node.js runs on the v8
</section>

<section>
Graal.js - node.js on the JVM
</section>

<section>
node.js also runs on chakracore (time travel debugging)
</section>


<section>
Electron 
</section>

<section>
Some editors are extendable with JS
</section>

<section>
Why do we want to run *Perl6* on JS?
</section>

<section>
Transpilers are common in JS land
</section>

<section>
People are even compiling JS to JS
</section>

<section>
JS is not fun for a lot of people
</section>

<section>
(I like JS, Perl 6 is just more awesome)
</section>

<section>
Fun matters.
</section>

<section>
"Isomorphic Perl 6"
</section>

<section>
Sharing code between backend and frontend
</section>

<section>
How?
</section>

<section>
Implementating Perl 6 on your own is a ton of work
</section>

<section>
I tried that before :/
</section>

<section>
Solution: A backend for Rakudo
</section>

<section>
A tale of two languages
</section>

<section>
  <ul>
    <li>NQP</li>
    <li>Perl 6</li>
  </ul>
</section>

<section>
  <ul>
    <li>NQP   ---> QAST</li>
    <li>Perl6 ---> QAST</li>
  </ul>
</section>

<section>
QAST ---> JS
</section>

<section>
  <pre>
  <code>
  is_qast(
      QAST::Block.new(
          QAST::Op.new(
              :op('if'),
              QAST::IVal.new(:value(1)),
              QAST::IVal.new(:value(2))
          )
      ),
      2,
      'if with IVal, 2-operand');
  </code>
  </pre>
</section>

<section>
nqp:: ops
</section>

<section>
  <pre>
  <code>
  say(nqp::add_i(12, 3));
  </code>
  </pre>
</section>

<section>
  <pre>
  <code>
  QAST::Op.new(
      :op('add_i'),
      QAST::IVal.new(:value(12)),
      QAST::IVal.new(:value(3))
  )
  </code>
  </pre>
</section>

<section>
writing tests for those
</section>

<section>
  <pre>
  <code>
ok( nqp::add_i(5,2) == 7, 'nqp::add_i');
ok( nqp::sub_i(5,2) == 3, 'nqp::sub_i');
ok( nqp::mul_i(5,2) == 10, 'nqp::mul_i');
ok( nqp::div_i(5,2) == 2, 'nqp::div_i');
is(nqp::div_i(-8, 3), -3, 'nqp::div_i');
is(nqp::div_i(9, -4), -3, 'nqp::div_i rounds down');
ok( nqp::mod_i(5,2) == 1, 'nqp::mod_i');
ok( nqp::pow_i(6, 4) == 1296, 'nqp::pow_i');
  </code>
  </pre>
</section>

<section>
Sometimes once building blocks are done, stuff works
</section>

<section>
<img src='lego.jpg'/>
</section>

<section>
Often loads of tedious debugging if I misunderstand some small detail
</section>

<section>
Source maps
<img src='help.png'/>
</section>

<section>
Support for them designed from the start
</section>

<section>
Native types
</section>

<section>
  <pre>
  <code>
  nqp::add_i(100, 200)
  </pre>
  </code>
</section>

<section>
  Compiled as:
  <pre>
  <code>
  (100+200)|0
  </pre>
  </code>
</section>

<section>
Continuations
</section>

<section>

  <pre>
  <code>
my $list = gather {
  say "#1";
  take 123;
  say "#2";
  take 456;
  say "#3";
  take 789;
};

say($list[1]);
say($list[2]);
say($list[3]);

  </code>
  </pre>

</section>

<section>
  <pre>
#1
123
#2
456
#3
789
  </pre>
</section>

<section>
On node.js we fibers
</section>

<section>
In the browser we sprinkle await/async
</section>

<section>
JavaScript is evolving towards becoming a better Perl 6 target
</section>

<section>
What's done?
</section>

<section>
We pass 55+% of roast test files on node.js
</section>

<section>
A few tricky lexical scope deserialization bugs
</section>

<section>
A bunch of SMOP bugs
</section>

<section>
Challenges
</section>

<section>
Performance is the big one
</section>

<section>
It's the biggest problem of other backends two
</section>

<section>
I want to fully undestand whag's needed before I start bending stuff
</section>

<section>
Performance of the compiler and user programs are two different things
</section>

<section>
NQP vs Perl 6
</section>

<section>
NQP can be tweaked
</section>

<section>
Perl 6 can't/shouldn't
</section>

<section>
For browser delivery code size matters
</section>

<section>
Tree shaking solves the problem for other languages
</section>

<section>
EVAL is a problem
</section>

<section>
Use that with :lang<JavaScript> only
</section>

<section>
Having a fast subset of Perl 6 is a more reachable goal
</section>

<section>
<img src='lego.jpg'/>
</section>

<section>
Why not target WebASM (or asm.js)?
<img src='wasm.png'/>
</section>

<section>
Currently it's like directly targeting a simple CPU
</section>

			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
